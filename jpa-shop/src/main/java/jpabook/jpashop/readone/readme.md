## 연관관계 매핑

- 용어 (고려사항)
    - 방향 : 양방향, 단방향
    - 다중성 : 다대일, 일대다, 일대일, 다대다
    - 연관관계의 주인 : 양방향 연관관계는 주인이 필요 
        - 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인(Owner)이라고 한다.
    

* 가급적 안시 표준 조인을 사용해야 다른 데이터베이스로 바꿔도 무리가 없다.


- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력 관계를 만들 수 없다.
    - 테이블은 외래키 하나로 조인을 사용해 연관된 테이블을 찾는다.
    - 객체는 참조를 사용해 연관된 객체를 찾는다. (객체의 양방향 관계는 서로다른 단방향의 참조관계가 2개이다.)
    
---

### @ManyToOne

- @JoinColumn 생략 가능

### @OneToMany 

- @JoinColumn을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다.(중간에 테이블을 하나 추가한다.)
- @OneToMany 를 추가하고 양방향 매핑을 사용하면 연관 관계의 주인을 mappedBy 로 지정 (대상이 되는 변수명)
  - Many-외래키가 있는 쪽이 주인이다.
    - 외래키가 없는 곳을 주인으로 할 경우 매우 불편하다. (다른 테이블의 외래 키를 관리해야함, 성능 이슈도 존재))
  - 주인만 외래키를 관리(등록, 수정)하고, 주인이 아닌쪽은 읽기만 가능


- 양방향 매핑시 가장 많이 하는 실수 : 연관관계의 주인에 값을 입력하지 않음
  - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 (연관관계 편의 메소드를 생성하자)
  - 순수한 객체까지 고려한 연관관계로 객체 관점에서 양쪽에 모두 값을 넣어주는 것이 안전하다.
  - 양방향 매핑시에 무한 루프를 조심하자 
      - 예: toString(), lombok, JSON 생성 라이브러리
      - toString lombok 은 왠만하면 쓰지말고, 컨트롤러에서 엔티티를 DTO로 만들어 반환하자.


- 단방향 매핑만으로도 이미 연관관계 매핑은 완료 / 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 편의를 위해 추가된 것 뿐이다.
- 기본적으로 단방향 매핑으로 하고 나중에 역방향으로 객체 탐색이 꼭 필요하다고 느낄 때 추가한다. (가급적 단방향이 좋다.)

--- 

### 다대일
- 단방향
  - 가장 많이 사용한다.
  - @ManyToOne
  - 다 쪽이 외래키를 가지고 있다.
  - 외래키가 있는곳에 참조를 걸어 연관관계 매핑을 하는 것
  

- 양방향
  - 반대쪽에 @OneToMany(mappedBy = "name") 를 추가하면 된다.

### 일대다
- 단방향
  - 1인 곳이 연관관계 주인
  - 외래키는 여전히 Many 쪽에 있고, 연관관계 매핑 시 추가로 Many 쪽에 외래키 Update 쿼리가 발생한다.
      - 반대편 테이블의 외래키를 관리하는 특이한 구조 (매우 불편하고 헷갈림)
  - @OneToMany
  - 권장하진 않음 (다대일 양방향을 사용하는걸 권장)
  - @JoinColumn 을 쓰지 않으면 중간테이블을 만들기 때문에 꼭 사용해야한다. (중간테이블 자체가 성능상 별로고, 운영이 쉽지않음)
  - 코드만으로 파악하기 힘든 쿼리 발생으로 헷갈릴 수 있다.


- 양방향
  - 야매로 사용가능한 방법 (공식적으로 존재하지 않음)
  - 다 쪽에 @ManyToOne + @JoinColumn(insertable=false, updatable=false) 를 추가한다. (읽기전용 필드를 사용)
  - 그냥 다대일 양방향 사용하자.

### 일대일
- 주 테이블이나 대상 테이블 중에 외래키 선택 가능
- 외래키에 데이터베이스 유니크 조건 추가
- 주 테이블에서 조회해야 lazy 동작
- @OneToOne
- @JoinColumn 필수

- 주 테이블에 외래키 단방향
  - 다대일 단방향과 유사하다. (제일 잘 쓴다.)


- 주 테이블에 외래키 양방향
  - @OneToOne 에 mappedBy 속성을 명시한다.


- 대상 테이블에 외래키 단방향
  - 지원하지 않음


- 대상 테이블에 외래키 양방향
  - 주 테이블에 외래키 양방향과 동일


- 딜레마가 있다.
  - 비즈니스 변동에 의한 수정
  - 명확하게 1대1 관계인지 초반 설계가 중요한 것 같다. (이 때 주 테이블에 외래키를 두는게 편함)


- 주 테이블에 외래키
  - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래키를 두고 대상 테이블을 찾는다.
  - 객체지향적
  - JPA 매핑 편리
  - 주 테이블만 조회해도 대상 테이블 데이터 확인 가능
  - 외래키에 null 허용


- 대상 테이블에 외래키
  - 대상 테이블에 외래키 존재
  - 데이터베이스 개발자가 선호
  - 주 테이블과 대상 테이블을 일대다 관계로 변경 시 구조 유지 가능
  - 프록시 기능의 한계로 지연로딩 설정을 해도 항상 즉시 로딩이 된다.
    - 지연로딩 시 연관된 엔티티가 있으면 프록시 객체가 대신 들어가면 되지만, 없으면 null 이 들어가야 한다.
    - 주 테이블에 외래키가 있으면 값이 있는지 없는지 주 테이블을 로딩하는 시점에 외래키 컬럼을 보고 확인할 수 있다.

### 다대다
- 중간 테이블을 추가해서 일대다, 다대일로 풀어낸다.
- @ManyToMany
- @JoinTable 로 연결 테이블 지정
- 단방향, 양방향 둘다 가능 (양방향 시 mappedBy 지정)
- 쓰면 안된다. (편해보이지만 실무에서 사용하면 안된다 -> 중간테이블을 수정할 수 없음)
- 중간 엔티티를 직접 만들고 일대다, 다대일로 직접 사용하는 것을 권장한다.


- 데이터베이스 설계 시 기본키값은 어딘가에 종속되어 설계하는것 보다 의미없는 값이나 자동 증가값으로 만드는 것을 권장한다. (확장성 및 유지보수에 좋음) 
  - 필요한 제약조건은 따로 추가하면 된다.

---

- 일대다 단방향 매핑의 문제는, 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는점 -> 관리가 어렵다.
- 가끔 JPA 값 타입을 사용하는 것을 대신하여 사용할 때는 유용한 경우가 있다.
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하는 것을 권장
- 사실 일대다 양방향 매핑은 존재하지 않음.


- 일대일 관계는 주 테이블에 외래키를 넣을 수도 있고, 대상 테이블에 외래키를 넣을 수도 있다. 
  - 일대일(1:1) 단방향 지원 안함
  - 일대일 관계라고 정하는 것 자체를 아주 신중하게 정했다고 가정한다면 주 테이블(Post)에 외래 키를 두는 것이 더 낫다.

---

### 상속관계 매핑

- 관계형 데이터베이스는 상속 관계가 없다.
- 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사
  

- 슈퍼타입, 서브타입 논리 모델을 실제 모델로 구현하는 방법
  - 각각 테이블로 변환 -> 조인 전략 (정석)
    - 테이블 정규화
    - 외래키 참조 무결성 제약조건 활용 가능 (다른 테이블에서 부모클래스 아이디만 보면 된다.)
    - 저장공간 효율화
    - 조회 시 조인을 많이사용해서 성능 저하 (상황에 따라 이점일 수도 있다.)
    - 조훠 쿼리가 복잡함
    - 데이터 저장 시 INSERT 2번 호출
    
  - 통합 테이블로 변환 -> 단일 테이블 전략
    - 조인이 필요없어서 성능이 빠름
    - 조회 쿼리가 단순
    - 단순한 테이블은 오래 고민하면 좋지 않음
    - 자식 엔티티가 매핑한 컬럼은 모두 NULL 허용
    - 단일 테이블에 모든것을 저장하므로 오히려 테이블이 커지면 느려질 수 있다.
    
  - 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략
    - not null 사용 가능
    - 서브 타입을 명확히 구분해야 할 때 효과적
    - 여러 자식 테이블을 함께 조회 시 성능이 느림 (UNION)
    - 자식 테이블을 통합하기 어려움
    - 권장하지 않는 전략
  

- @Inheritance(strategy = InheritanceType.XXX)
  - JOINED : 조인 전략
  - SINGLE_TABLE : 단일 테이블 전략
  - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 (이 때 추상클래스로 부모 클래스 생성, 부모클래스로 조회 시 전부 유니온으로 가져와서 성능이 별로다.)
  

- @DiscriminatorColumn(name=“DTYPE”) : 컬럼 구분값 생성 (부모에 설정), 단일 테이블 전략에선 필수로 생성된다.
- @DiscriminatorValue(“XXX”) : 구분값 형태 정의 (자식에 설정)


- @MappedSuperclass
  - 상속관계 매핑X 
  - 엔티티X, 테이블과 매핑X
  - 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공 조회, 검색 불가(em.find(BaseEntity) 불가)
  - 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
  - 공통 매핑 정보가 필요할 때 사용한다.
  - 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
  - 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통 으로 적용하는 정보를 모을 때 사용
  - 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
  

- 처음엔 객체지향적으로 가다가 나중에 성능 이슈 발생 시 변경을 고려해도 된다.

---

### 프록시

- 연관관계에 있는 객체가 필요없는 상황일 때 함께 조회해 올 필요가 없다. (낭비)
- JPA 는 지연로딩, 프록시로 해결한다.

- em.getReference() : JPA 에서 데이터베이스 조회를 미루는 가짜 프록시 엔티티를 조회, 실제로 사용할 때 조회해온다.
- 프록시가 호출되는 순간 영속성 컨텍스트에 초기화 요청을 하고, DB 를 조회하여 실제 엔티티를 생성한다.

#### 프록시의 특징
- 프록시 객체는 처음 사용할 때 한번만 초기화
- 초기화 시 프록시 객체가 실제 엔티티로 바뀌는 게 아니라 프록시 객체를 통해 실제 엔티티에 접근하는 것
- 프록시 객체는 원본 엔티티를 상속받음 -> 타입 체크 시 주의 (instance of 사용 권장)
- 영속성 컨텍스트에 엔티티가 이미 있으면 em.getReference() 를 호출해도 실제 엔티티를 반환한다.
- 프록시 객체도 같은 프록시 객체를 반환함
- 먼저 프록시를 조회하고 나중에 find 해도 find 할때 반환되는 객체는 프록시다.
  - JPA 는 트랜잭션 안에서 동일한 값을 보장하기 때문
- 준영속 상태일 땐 예외가 발생한다! (LazyInitializationException - no Session)

#### 프록시 확인
- 프록시 인스턴스의 초기화 여부 확인 : PersistenceUnitUtil.isLoaded(Object entity) - emf 객체로부터 PersistenceUnitUtil 조회
- 프록시 클래스 확인 : entity.getClass().getName() 출력
- 프록시 강제 초기화 : org.hibernate.Hibernate.initialize(entity); (JPA 표준은 지원안함)
- 강제 호출 : member.getName() (그냥 객체 참조)
                                               
- 프록시 객체의 필수요소는 PK
- 지연로딩 객체가 바로 프록시를 활용한 것!
- 프록시의 PK를 제외한 다른 필드에 대한 접근이 생길때 PK를 기준으로 영속성컨텍스트에서 존재유무를 파악한 뒤, 존재하지 않으면 쿼리를 날려 프록시의 다른필드들을 초기화 한다.

### 즉시 로딩과 지연 로딩
- 상황에 따라 로딩 시점을 설정할 수 있다.
- 실무에선 가급적 지연로딩만 사용한다. (정말 정말 자주 같이 사용하는 놈이 있다면 즉시로딩..)
- 즉시 로딩을 적용하면 예상치 못한 SQL 이 발생할 수 있다. (쿼리가 막 나가면서 성능 이슈가 발생한다면 즉시로딩인지 확인하자..)
- 즉시 로딩은 JPQL 에서 N+1 문제를 일으킨다. (내부적으로 JPA가 최적화하는 em.find 같은 게 아닌 JPQL은 먼저 SQL로 그 자체를 번역하여 실행하고 난 후 연관관계 관련 쿼리를 보고 별도로 하나하나 실행함)
  - 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 이를 N+1 문제라고 한다.
  - 해결방안
    - 먼저 Lazy 로 설정한다.
    - fetch join, batch size, @entityGraph 중 선택하여 해결
                                                       
#### 즉시로딩
- 조인으로 한번에 조회
- FetchType.EAGER

#### 지연로딩
- 프록시로 사용 시 조회
- FetchType.LAZY

---

### 영속성 전이

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶다면?
  - Ex. 부모 엔티티 저장 시 자식 엔티티도 함께 저장
- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함 을 제공할 뿐
- 소유자가 하나일 경우 (개인 소유)에만 사용해야한다. + 부모와 자식의 라이프사이클이 같을 때
- 보통 @OneToOne, @OneToMany 에 쓰는듯

#### CASCADE 종류
- ALL: 모두 적용
- PERSIST: 영속
- REMOVE: 삭제
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

#### 고아객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티 를 자동으로 삭제
- orphanRemoval = true (false 일 경우 연관관계가 끊어진 객체의 외래키는 null 값이 된다.)

- 주의
  - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
  - 참조하는 곳이 하나일 때 사용해야한다. (특정 엔티티가 개인 소유할 때 사용)
  - @OneToOne, @OneToMany만 가능
  - 참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고 아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. => CascadeType.REMOVE 처럼 동작한다.
                                                                                                                 
#### 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemovel=true
  - 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
  - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 함께 관리할 수 있음!
  - 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용
    - Aggregate Root 는 Parent, Aggregate Root 가 관리하는 애들이 Child
  
