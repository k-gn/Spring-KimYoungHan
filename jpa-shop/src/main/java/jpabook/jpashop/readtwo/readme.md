### 값타입

- 엔티티 타입
    - @Entity로 정의하는 객체
    - 데이터가 변해도 식별자로 지속해서 추적 가능
    - 예) 회원엔티티의 키나 나이값을 변경해도 식별자로 인식 가능
    

- 값 타입
    - int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
    - 식별자가 없고 값만 있으므로 변경시 추적 불가
    - 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

#### 기본값 타입
- 자바 기본타입, 래퍼클래스, 문자열
- 생명주기를 엔티티에 의존
  - 회원 삭제 시 이름, 나이도 함께 삭제
- 값 타입은 공유되지 않음
  - 회원 이름 변경 시 다른 회원의 이름도 함께 변경 x
- 기본타입은 항상 값을 복사해서 절대 공유되지 않고, 래퍼클래스나 String 같은 클래스는 공유 가능한 객체지만 변경되지 않음
- 변경되지 않다는 것 -> 사이드 이펙트가 없다 -> 안전하다!

#### 임베디드 타입
- 복합값 타입
- 새로운 값 타입을 직접 정의할 수 있다.
- 주로 기본값타입을 모아 만든다.
- 단순히 엔티티의 값일 뿐이다.
- 임베디드 사용 전과 후에 테이블은 동일하다.
- 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능 (활용도가 높아짐)
- 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수보다 클래스 수가 더 많다.


- @Embeddable : 값 타입을 정의하는 곳에 사용
- @Embedded : 값 타입을 사용하는 곳에 사용
- 기본 생성자 필수!
- 임베디드 타입은 다른 임베디드 타입을 가질 수 있다.
- 임베디드 타입은 다른 엔티티를 가질 수 있다. (실제론 FK 를 가짐)
- @Column 같은 어노테이션도 사용 가능


- 한 엔티티에서 같은 임베디드 값 타입을 사용할 경우 컬럼명이 중복될 수 있다.
  - @AttributeOverrides, @AttributeOverride를 사용해서 컬러명 속성을 재정의한다.
- 임베디드 타입이 자체가 null 이면 내부 값들도 전부 빈 값이다.


- 장점
  - 재사용, 높은 응집도
  - 값 타입만 사용하는 의미 있는 메소드를 만들 수 있다.
  - 임베디드 타입을 포함한 모든 값타입은 소유한 엔티티에 생명주기를 의존한다.
    - 엔티티가 생기면 같이 생기고, 사라지면 같이 사라진다.

#### 값타입과 불변객체

- 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.
- 무언가를 공유하는 임베디드 값타입이라면 엔티티로 만들어서 사용해야한다. (주소를 공유해야하면 값타임이 아닌 주소 엔티티를 만들어야한다.)
- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다. (사이드 이펙트 발생)
  - ex. 같은 임베디드 주소 값타입을 가진 회원 두명 중 한명이 주소를 수정할 경우 Update 가 두번 발생하면서 같이 수정된다 -> 치명적인 예외, 찾기도 힘듬
- 임베디드 타입을 공유하려면 복사해서 사용해야한다.
  - 항상 값을 복사해서 사용하면 공융참조로 발생하는 부작용을 피할수 있다.
  - 문제는 임베디드 타입처럼 직접 정의한 값타입은 자바의 객체 타입이다.
    - 자바 기본타입에 값을 대입하면 값을 복사하기 때문에 문제가 없다. 
    - 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.
    - 즉, 객체의 공유참조는 피할 수 없다.
  

- 불변객체
  - 객체 타입을 수정할 수 없게 만들면 부작용을 차단하는 것!
  - 값타입은 불변객체로 설계해야한다. (큰 재앙을 막을 수 있다..!)
  - 생성 시점 이후 절대 값을 변경할 수 없게 해야하는 것
  - 생성자로만 값을 설정하고 Setter(수정자)를 만들지 않으면 된다.
  - Integer (Wrapper class), String 이 대표적인 불변객체
    - 기존 주소의 값을 변경하는게 아닌 새로운 주소에 값을 할당한다.


- 값을 바꾸고 싶다면?
  - 새로운 객체 자체를 만들어서 다시 넣어준다. 
  
#### 값타입의 비교

- 값 타입은 인스턴스가 달라도 그 안에 값이 같으면 같은 값으로 판단해야 한다.
  - 따라서 equals 와 hashCode 메소드를 적절히 재정의하여 사용해야한다.
  - 더 복잡한 비즈니스 요구사항이 생길 경우 값을 하나씩 꺼내서 비교할 수도 있다.

#### 값타입 컬렉션

- 값타입을 컬렉션에 담아 쓰는 것
- 값타임 컬렉션도 생명주기를 엔티티에 의존한다.
- 값타입을 하나 이상 저장할 때 사용
- 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.
  - 관계형 데이터베이스는 기본적으로 컬렉션을 담을 수 있는 컬럼이 없어서 별도의 테이블로 뽑는다.
  - 가능한 데이터베이스도 있다. (ex. json type)
- 외래키 + 모든 컬럼이 복합키로 묶은 테이블이 생성된다.

- @ElementCollection, @CollectionTable 사용
  - @CollectionTable 내에서 @JoinColumn 을 사용해 외래키 지정 가능
  

- 지연로딩 전략 사용
- 영속성 전이, 고아객체 제거기능을 필수로 가지고 있다.
- 수정 시 기존 값을 제거하고 다시 등록한다.
  - 기본적으로 컬렉션들을 대부분 equals 로 객체를 비교하기 때문에 재정의를 잘해줘야한다.
  
- 값타입 컬렉션 제약사항 
  - 엔티티와 다르게 식별자 개념이 없다.
  - 값은 변경하면 추적이 어렵다.
  - 값타입 컬렉션에 변경사항이 일어나면 엔티티와 연관된 모든 데이터를 삭제하고, 현재 컬렉션 값을 모두 다시 저장한다.
      - @OrderColumn 을 사용해 해결은 가능하다. (완벽한 해결은 아니다.)
  - 값타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키로 구성 : null 입력 x, 중복 x


- 사용을 지양한다. (정말 단순할 경우 사용) / 그냥 왠만하면 다 엔티티다.
- 실무에선 상황에 따라 값타입 컬렉션 대신 일대다 관계를 고려한다. (이럴 때 일대다를 사용하면 낫배드)
  - 일대다 관계를 위한 엔티티를 만들고, 그 안에서 값타입을 사용


---

- 엔티티 타입 특징
  - 식별자 O
  - 생명주기 관리
  - 공유

- 값타입 특징
  - 식별자 X
  - 생명주기를 엔티티에 의존
  - 공유하지 않는 것이 안전 (복사해서 사용하거나 불변객체로 사용)

  
- 값 타입은 정말 값 이라고 판단될 때 사용
- 엔티티와 값 타입을 혼동해서 엔티티를 값타입으로 만들면 안된다.
- 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티
  

* @ElementCollection 말고는 Querydsl 에서 기본적으로 정상 동작한다.

---