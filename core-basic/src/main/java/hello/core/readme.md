## SOLID
1. 단일 책임의 원칙 - SRP
    - 한 클래스는 하나의 책임만 가진다.
    - 문맥과 상황에 따라 다르다.
    - 중요한 기준은 변경이다.
        - 변경이 있을 때 파급 효과가 적으면 잘 따른 것

2. 개방 폐쇄의 원칙 - OCP
    - 확장에는 열려있고, 변경에는 닫혀 있어야 한다.
    - 다형성을 활용
        - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
    - 역할과 구현의 분리

3. 리스코프 치환 원칙 - LSP
    - 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - ex) 앞으로 가자고 정의한 엑셀 +10 / -10
    - 단순히 컴파일 성공이 아닌 의미적 차원의 이야기

4. 의존 역전의 원칙 - DIP
    - 추상화에 의존해야지 구체화에 의존하면 안된다.
        - 즉, 구현 클래스에 의존하지 않고 인터페이스에 의존해라.
    - 역할에 의존해야 한다는 것과 같다.
    - 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. (아니면 변경이 아주 어려워진다.)

5. 인터페이스 분리 원칙 - ISP
    - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
    - 자동차 -> 운전 + 정비
    - 사용자 -> 운전자 + 정비사
        - 정비 인터페이스 자체가 변해도 운전자는 영향을 받지 않음
    - 인터페이스가 더 명확해지고 대체 가능성이 높아진다.
    
---

### 인식하는 어노테이션과 부가기능

1. @Controller : 스프링 MVC 컨트롤러에 사용
    - 스프링 MVC 컨트롤러로 인식
2. @Service : 스프링 비즈니스 로직에서 사용
    - 개발자가 핵심 비즈니스 로직이 여기 있구나~ 하고 인지하게 해준다.
3. @Repository : 스프링 데이터 접근 계층에서 사용
    - 스프링 데이터 접근 계층으로 인식하고 데이터 계층의 예외를 스프링 예외로 변환(추상화) 헤준다.
4. @Configuration : 스프링 설정 정보에서 사용
    - 스프링 설정 정보로 인식하고 빈이 싱글톤을 유지하도록 해준다.
    - 애노테이션을 들어가보면 내부에 @Component 가 있는 것을 볼 수 있다.
        - 애노테이션은 상속관계가 존재하지 않지만 스프링이 지원해준다.
    

---

## 생성자 주입을 선택해라!
- "불변"
    - 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
    - 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.
    - 수정자 주입을 사용하면 setter 메서드를 public 으로 열어두어여 한다.
    - 누군가 실수로 변경할 수 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계방법이 아니다.
    - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이 후에 호출되는 일이 없어 불변하게 설계할 수 있다.
    - 순환참조를 방지할 수 있다.

- "누락"
    - 프레임워크 없이 순수 자바 코드를 단위 테스트하는 경우 수정자 의존관계라면 @Autowired 시 의존관계가 없을 때 오류가 발생한다.
    - 하지만 오류가 나는지 안나는지 실행해야 확인이 가능하다.
    - 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이다.
    - 필드에 final 키워드를 사용할 수 있다. -> 생성자에 값이 설정되지 않는 오류를 컴파일 시점에 확인이 가능하다.

생성자 주입과 수정자 주입은 동시에 사용할 수 있다.
기본적으로 생성자 주입을 사용하고, 필수값이 아닌 경우 수정자 주입방식을 옵션으로 부여하면 된다.

---

## 자동, 수동의 올바른 실무 운영 기준
- 편리한 자동 기능을 기본으로 사용하자!
- 스프링은 점점 자동을 선호하는 추세이다!
- 자동 빈 등록을 사용해도 OCP, DIP 를 지킬 수 있다!
- 수동으로 만든 빈들의 설정정보가 커질 수록 관리하기가 힘들어진다!

## 그럼 수동 빈 등록은 언제 사용할까?
- 애플리케이션은 크게 업무로직과 기술지원로직으로 나뉜다.
- 업무로직 빈 : 컨트롤러, 서비스, 레포지토리 등 - 보통 비즈니스 요구사항을 개발할 때 추가 / 변경된다.
    - 숫자도 많고, 유사한 패턴이 있어 자동 기능을 적극 사용하는 것이 좋다.
    - 어떤 곳에서 문제가 발생했는지 명확히 파악하기 쉽다.
- 기술지원 빈 : 기술적 문제나 공통 관심사 (AOP) 처리 시 주로 사용된다. 데이터베이스 연결, 공통 로그처리 처럼 업무 로직을 지원하기 위한 기술이다.
    - 수가 매우 적고, 애플리케이션 전반에 걸쳐 광범위하게 영향을 미친다.
    - 잘 적용되어 있는지 파악하기 어려운 경우가 많다.
    - 따라서 수동 빈 등록으로 명확하게 들어내는 것이 좋다.

- 스프링과 스프링부트가 자동으로 등록하는 많은 빈들은 예외다. (메뉴얼을 참조하여 의도한 대로 편하게 사용하면 됨)
- 내가 직접 기술 지원 객체를 빈으로 등록한다면 수동으로 등록하는 것이 좋다.

- 비즈니스 로직 중에서 다형성을 적극 활용할 때 (조회한 빈이 모두 필요할 때 List, Map 사용한 부분)
    - 어떤 빈들이 주입될 지, 각 빈들의 이름이 뭔지 한눈에 코드만 보고 파악하기 힘들다. (하나하나 찾아 들어가서 확인해야함)
    - 이런 경우 수동 빈으로 등록하거나 자동으로 할 경우 구현 빈들을 특정 패키지에 같이 묶어 두는 것이 좋다!